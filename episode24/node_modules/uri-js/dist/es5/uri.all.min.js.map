{"version":3,"sources":["../../src/util.ts","../../src/regexps-uri.ts","../../node_modules/punycode/punycode.es6.js","../../src/uri.ts","../../src/schemes/mailto.ts","../../src/regexps-iri.ts","../../src/schemes/http.ts","../../src/schemes/https.ts","../../src/schemes/urn.ts","../../src/schemes/urn-uuid.ts","../../src/index.ts"],"names":["merge","sets","Array","_len","_key","arguments","length","slice","xl","x","join","subexp","str","typeOf","o","undefined","Object","prototype","toString","call","split","pop","shift","toLowerCase","toUpperCase","toArray","obj","setInterval","buildExps","isIRI","HEXDIG$$","PCT_ENCODED$","SUB_DELIMS$$","RESERVED$$","UCSCHAR$$","DEC_OCTET$","IPV4ADDRESS$","H16$","LS32$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","RegExp","UNRESERVED$$","IPRIVATE$$","IPV6ADDRESS$","error","type","RangeError","errors","map","array","fn","result","mapDomain","string","parts","replace","regexSeparators","ucs2decode","output","counter","value","charCodeAt","extra","push","pctEncChar","chr","c","pctDecChars","newStr","i","il","parseInt","substr","String","fromCharCode","c2","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","match","UNRESERVED","scheme","PCT_ENCODED","NOT_SCHEME","userinfo","NOT_USERINFO","host","NOT_HOST","path","NOT_PATH","NOT_PATH_NOSCHEME","query","NOT_QUERY","fragment","NOT_FRAGMENT","parse","uriString","options","iri","IRI_PROTOCOL","URI_PROTOCOL","reference","matches","URI_PARSE","NO_MATCH_IS_UNDEFINED","port","isNaN","indexOf","IPV6ADDRESS","schemeHandler","SCHEMES","unicodeSupport","domainHost","punycode","toASCII","e","_recomposeAuthority","uriTokens","removeDotSegments","input","RDS1","RDS2","RDS3","im","RDS5","Error","s","serialize","test","toUnicode","authority","charAt","absolutePath","resolveComponents","base","relative","skipNormalization","target","tolerant","lastIndexOf","resolve","baseURI","relativeURI","normalize","uri","equal","uriA","uriB","escapeComponent","ESCAPE","unescapeComponent","maxInt","regexPunycode","regexNonASCII","floor","Math","stringFromCharCode","ucs2encode","fromCodePoint","apply","toConsumableArray","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","baseMinusTMin","decode","inputLength","n","bias","basic","j","index","oldi","w","t","baseMinusT","out","splice","encode","_step","Symbol","iterator","_iteratorNormalCompletion","_iterator","next","done","currentValue","basicLength","handledCPCount","m","_step2","_iteratorNormalCompletion2","_iterator2","handledCPCountPlusOne","_step3","_iteratorNormalCompletion3","_iterator3","q","qMinusT","http","https","O","VCHAR$$","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","mailto","to","unknownHeaders","headers","hfields","hfield","toAddrs","subject","body","addr","toAddr","atIdx","localPart","domain","fields","name","URN_SCHEME","urn","UUID","uuid"],"mappings":"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","file":"dist/es5/uri.all.min.js","sourcesContent":["export function merge(...sets:Array<string>):string {\n\tif (sets.length > 1) {\n\t\tsets[0] = sets[0].slice(0, -1);\n\t\tconst xl = sets.length - 1;\n\t\tfor (let x = 1; x < xl; ++x) {\n\t\t\tsets[x] = sets[x].slice(1, -1);\n\t\t}\n\t\tsets[xl] = sets[xl].slice(1);\n\t\treturn sets.join('');\n\t} else {\n\t\treturn sets[0];\n\t}\n}\n\nexport function subexp(str:string):string {\n\treturn \"(?:\" + str + \")\";\n}\n\nexport function typeOf(o:any):string {\n\treturn o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n}\n\nexport function toUpperCase(str:string):string {\n\treturn str.toUpperCase();\n}\n\nexport function toArray(obj:any):Array<any> {\n\treturn obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n}\n","import { URIRegExps } from \"./uri\";\nimport { merge, subexp } from \"./util\";\n\nexport function buildExps(isIRI:boolean):URIRegExps {\n\tconst\n\t\tALPHA$$ = \"[A-Za-z]\",\n\t\tCR$ = \"[\\\\x0D]\",\n\t\tDIGIT$$ = \"[0-9]\",\n\t\tDQUOTE$$ = \"[\\\\x22]\",\n\t\tHEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),  //case-insensitive\n\t\tLF$$ = \"[\\\\x0A]\",\n\t\tSP$$ = \"[\\\\x20]\",\n\t\tPCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),  //expanded\n\t\tGEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\tSUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\tRESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\tUCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",  //subset, excludes bidi control characters\n\t\tIPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",  //subset\n\t\tUNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\tSCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\tUSERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\tDEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\tIPV4ADDRESS$ = subexp(DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$),\n\t\tH16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\tLS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\tIPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n\t\tIPV6ADDRESS2$ = subexp(                                                 \"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n\t\tIPV6ADDRESS3$ = subexp(subexp(                                 H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\tIPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\tIPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\tIPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" +        H16$ + \"\\\\:\"          + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\tIPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\"                                + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\tIPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\"                                + H16$ ), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\tIPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"                                       ), //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\tIPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\tIPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\tIP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n\t\tREG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\tHOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\tPORT$ = subexp(DIGIT$$ + \"*\"),\n\t\tAUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\tPCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\tSEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\tSEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\tSEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\tPATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\tPATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),  //simplified\n\t\tPATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\tPATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tQUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\tFRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\tHIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tURI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tRELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\tRELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tURI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\tABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\n\t\tGENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tRELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\tSAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tAUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\"\n\t;\n\n\treturn {\n\t\tNOT_SCHEME : new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\tNOT_USERINFO : new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_HOST : new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH : new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH_NOSCHEME : new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_QUERY : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\tNOT_FRAGMENT : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\tESCAPE : new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tUNRESERVED : new RegExp(UNRESERVED$$, \"g\"),\n\t\tOTHER_CHARS : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\tPCT_ENCODED : new RegExp(PCT_ENCODED$, \"g\"),\n\t\tIPV6ADDRESS : new RegExp(\"\\\\[?(\" + IPV6ADDRESS$ + \")\\\\]?\", \"g\")\n\t};\n}\n\nexport default buildExps(false);\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport default punycode;\n","/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\n\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf } from \"./util\";\n\nexport interface URIComponents {\n\tscheme?:string,\n\tuserinfo?:string,\n\thost?:string,\n\tport?:number|string,\n\tpath?:string,\n\tquery?:string,\n\tfragment?:string,\n\treference?:string,\n\terror?:string\n}\n\nexport interface URIOptions {\n\tscheme?:string,\n\treference?:string,\n\ttolerant?:boolean,\n\tabsolutePath?:boolean,\n\tiri?:boolean,\n\tunicodeSupport?:boolean,\n\tdomainHost?:boolean\n}\n\nexport interface URISchemeHandler {\n\tscheme:string,\n\tparse(components:URIComponents, options:URIOptions):URIComponents,\n\tserialize(components:URIComponents, options:URIOptions):URIComponents,\n\tunicodeSupport?:boolean,\n\tdomainHost?:boolean,\n\tabsolutePath?:boolean\n}\n\nexport interface URIRegExps {\n\tNOT_SCHEME : RegExp,\n\tNOT_USERINFO : RegExp,\n\tNOT_HOST : RegExp,\n\tNOT_PATH : RegExp,\n\tNOT_PATH_NOSCHEME : RegExp,\n\tNOT_QUERY : RegExp,\n\tNOT_FRAGMENT : RegExp,\n\tESCAPE : RegExp,\n\tUNRESERVED : RegExp,\n\tOTHER_CHARS : RegExp,\n\tPCT_ENCODED : RegExp,\n\tIPV6ADDRESS : RegExp\n}\n\nexport const SCHEMES:{[scheme:string]:URISchemeHandler} = {};\n\nexport function pctEncChar(chr:string):string {\n\tconst c = chr.charCodeAt(0);\n\tlet e:string;\n\n\tif (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n\telse if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n\telse if (c < 2048) e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\telse e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\n\treturn e;\n}\n\nexport function pctDecChars(str:string):string {\n\tlet newStr = \"\";\n\tlet i = 0;\n\tconst il = str.length;\n\n\twhile (i < il) {\n\t\tconst c = parseInt(str.substr(i + 1, 2), 16);\n\n\t\tif (c < 128) {\n\t\t\tnewStr += String.fromCharCode(c);\n\t\t\ti += 3;\n\t\t}\n\t\telse if (c >= 194 && c < 224) {\n\t\t\tif ((il - i) >= 6) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 6);\n\t\t\t}\n\t\t\ti += 6;\n\t\t}\n\t\telse if (c >= 224) {\n\t\t\tif ((il - i) >= 9) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tconst c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 9);\n\t\t\t}\n\t\t\ti += 9;\n\t\t}\n\t\telse {\n\t\t\tnewStr += str.substr(i, 3);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn newStr;\n}\n\nfunction _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {\n\tfunction decodeUnreserved(str:string):string {\n\t\tconst decStr = pctDecChars(str);\n\t\treturn (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n\t}\n\n\tif (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\tif (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\n\treturn components;\n};\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[\\dA-F:.]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>(\"\").match(/(){0}/))[1] === undefined;\n\nexport function parse(uriString:string, options:URIOptions = {}):URIComponents {\n\tconst components:URIComponents = {};\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\n\tif (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\n\tconst matches = uriString.match(URI_PARSE);\n\n\tif (matches) {\n\t\tif (NO_MATCH_IS_UNDEFINED) {\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1];\n\t\t\tcomponents.userinfo = matches[3];\n\t\t\tcomponents.host = matches[4];\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = matches[7];\n\t\t\tcomponents.fragment = matches[8];\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = matches[5];\n\t\t\t}\n\t\t} else {  //IE FIX for improper RegExp matching\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1] || undefined;\n\t\t\tcomponents.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n\t\t\tcomponents.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n\t\t\tcomponents.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n\t\t\t}\n\t\t}\n\n\t\t//strip brackets from IPv6 hosts\n\t\tif (components.host) {\n\t\t\tcomponents.host = components.host.replace(protocol.IPV6ADDRESS, \"$1\");\n\t\t}\n\n\t\t//determine reference type\n\t\tif (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t\tcomponents.reference = \"same-document\";\n\t\t} else if (components.scheme === undefined) {\n\t\t\tcomponents.reference = \"relative\";\n\t\t} else if (components.fragment === undefined) {\n\t\t\tcomponents.reference = \"absolute\";\n\t\t} else {\n\t\t\tcomponents.reference = \"uri\";\n\t\t}\n\n\t\t//check for reference errors\n\t\tif (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t\tcomponents.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t}\n\n\t\t//find scheme handler\n\t\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t\t//check if scheme can't handle IRIs\n\t\tif (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t\t//if host component is a domain name\n\t\t\tif (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\tcomponents.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//convert IRI -> URI\n\t\t\t_normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t} else {\n\t\t\t//normalize encodings\n\t\t\t_normalizeComponentEncoding(components, protocol);\n\t\t}\n\n\t\t//perform scheme specific parsing\n\t\tif (schemeHandler && schemeHandler.parse) {\n\t\t\tschemeHandler.parse(components, options);\n\t\t}\n\t} else {\n\t\tcomponents.error = components.error || \"URI can not be parsed.\";\n\t}\n\n\treturn components;\n};\n\nfunction _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\tif (components.userinfo !== undefined) {\n\t\turiTokens.push(components.userinfo);\n\t\turiTokens.push(\"@\");\n\t}\n\n\tif (components.host !== undefined) {\n\t\t//ensure IPv6 addresses are bracketed\n\t\turiTokens.push(String(components.host).replace(protocol.IPV6ADDRESS, \"[$1]\"));\n\t}\n\n\tif (typeof components.port === \"number\") {\n\t\turiTokens.push(\":\");\n\t\turiTokens.push(components.port.toString(10));\n\t}\n\n\treturn uriTokens.length ? uriTokens.join(\"\") : undefined;\n};\n\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\nexport function removeDotSegments(input:string):string {\n\tconst output:Array<string> = [];\n\n\twhile (input.length) {\n\t\tif (input.match(RDS1)) {\n\t\t\tinput = input.replace(RDS1, \"\");\n\t\t} else if (input.match(RDS2)) {\n\t\t\tinput = input.replace(RDS2, \"/\");\n\t\t} else if (input.match(RDS3)) {\n\t\t\tinput = input.replace(RDS3, \"/\");\n\t\t\toutput.pop();\n\t\t} else if (input === \".\" || input === \"..\") {\n\t\t\tinput = \"\";\n\t\t} else {\n\t\t\tconst im = input.match(RDS5);\n\t\t\tif (im) {\n\t\t\t\tconst s = im[0];\n\t\t\t\tinput = input.slice(s.length);\n\t\t\t\toutput.push(s);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected dot segment condition\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.join(\"\");\n};\n\nexport function serialize(components:URIComponents, options:URIOptions = {}):string {\n\tconst protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\t//find scheme handler\n\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t//perform scheme specific serialization\n\tif (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n\tif (components.host) {\n\t\t//if host component is an IPv6 address\n\t\tif (protocol.IPV6ADDRESS.test(components.host)) {\n\t\t\t//TODO: normalize IPv6 address as per RFC 5952\n\t\t}\n\n\t\t//if host component is a domain name\n\t\telse if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n\t\t\t//convert IDN via punycode\n\t\t\ttry {\n\t\t\t\tcomponents.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n\t\t\t} catch (e) {\n\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//normalize encoding\n\t_normalizeComponentEncoding(components, protocol);\n\n\tif (options.reference !== \"suffix\" && components.scheme) {\n\t\turiTokens.push(components.scheme);\n\t\turiTokens.push(\":\");\n\t}\n\n\tconst authority = _recomposeAuthority(components, options);\n\tif (authority !== undefined) {\n\t\tif (options.reference !== \"suffix\") {\n\t\t\turiTokens.push(\"//\");\n\t\t}\n\n\t\turiTokens.push(authority);\n\n\t\tif (components.path && components.path.charAt(0) !== \"/\") {\n\t\t\turiTokens.push(\"/\");\n\t\t}\n\t}\n\n\tif (components.path !== undefined) {\n\t\tlet s = components.path;\n\n\t\tif (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t\ts = removeDotSegments(s);\n\t\t}\n\n\t\tif (authority === undefined) {\n\t\t\ts = s.replace(/^\\/\\//, \"/%2F\");  //don't allow the path to start with \"//\"\n\t\t}\n\n\t\turiTokens.push(s);\n\t}\n\n\tif (components.query !== undefined) {\n\t\turiTokens.push(\"?\");\n\t\turiTokens.push(components.query);\n\t}\n\n\tif (components.fragment !== undefined) {\n\t\turiTokens.push(\"#\");\n\t\turiTokens.push(components.fragment);\n\t}\n\n\treturn uriTokens.join(\"\");  //merge tokens into a string\n};\n\nexport function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {\n\tconst target:URIComponents = {};\n\n\tif (!skipNormalization) {\n\t\tbase = parse(serialize(base, options), options);  //normalize base components\n\t\trelative = parse(serialize(relative, options), options);  //normalize relative components\n\t}\n\toptions = options || {};\n\n\tif (!options.tolerant && relative.scheme) {\n\t\ttarget.scheme = relative.scheme;\n\t\t//target.authority = relative.authority;\n\t\ttarget.userinfo = relative.userinfo;\n\t\ttarget.host = relative.host;\n\t\ttarget.port = relative.port;\n\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\ttarget.query = relative.query;\n\t} else {\n\t\tif (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t\t//target.authority = relative.authority;\n\t\t\ttarget.userinfo = relative.userinfo;\n\t\t\ttarget.host = relative.host;\n\t\t\ttarget.port = relative.port;\n\t\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\t\ttarget.query = relative.query;\n\t\t} else {\n\t\t\tif (!relative.path) {\n\t\t\t\ttarget.path = base.path;\n\t\t\t\tif (relative.query !== undefined) {\n\t\t\t\t\ttarget.query = relative.query;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.query = base.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (relative.path.charAt(0) === \"/\") {\n\t\t\t\t\ttarget.path = removeDotSegments(relative.path);\n\t\t\t\t} else {\n\t\t\t\t\tif ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t\t\t\t\ttarget.path = \"/\" + relative.path;\n\t\t\t\t\t} else if (!base.path) {\n\t\t\t\t\t\ttarget.path = relative.path;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t\t\t\t}\n\t\t\t\t\ttarget.path = removeDotSegments(target.path);\n\t\t\t\t}\n\t\t\t\ttarget.query = relative.query;\n\t\t\t}\n\t\t\t//target.authority = base.authority;\n\t\t\ttarget.userinfo = base.userinfo;\n\t\t\ttarget.host = base.host;\n\t\t\ttarget.port = base.port;\n\t\t}\n\t\ttarget.scheme = base.scheme;\n\t}\n\n\ttarget.fragment = relative.fragment;\n\n\treturn target;\n};\n\nexport function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {\n\treturn serialize(resolveComponents(parse(baseURI, options), parse(relativeURI, options), options, true), options);\n};\n\nexport function normalize(uri:string, options?:URIOptions):string;\nexport function normalize(uri:URIComponents, options?:URIOptions):URIComponents;\nexport function normalize(uri:any, options?:URIOptions):any {\n\tif (typeof uri === \"string\") {\n\t\turi = serialize(parse(uri, options), options);\n\t} else if (typeOf(uri) === \"object\") {\n\t\turi = parse(serialize(<URIComponents>uri, options), options);\n\t}\n\n\treturn uri;\n};\n\nexport function equal(uriA:string, uriB:string, options?: URIOptions):boolean;\nexport function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;\nexport function equal(uriA:any, uriB:any, options?:URIOptions):boolean {\n\tif (typeof uriA === \"string\") {\n\t\turiA = serialize(parse(uriA, options), options);\n\t} else if (typeOf(uriA) === \"object\") {\n\t\turiA = serialize(<URIComponents>uriA, options);\n\t}\n\n\tif (typeof uriB === \"string\") {\n\t\turiB = serialize(parse(uriB, options), options);\n\t} else if (typeOf(uriB) === \"object\") {\n\t\turiB = serialize(<URIComponents>uriB, options);\n\t}\n\n\treturn uriA === uriB;\n};\n\nexport function escapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n};\n\nexport function unescapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n};\n","import { URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\n\nexport interface MailtoHeaders {\n\t[hfname:string]:string\n}\n\nexport interface MailtoComponents extends URIComponents {\n\tto:Array<string>,\n\theaders?:MailtoHeaders,\n\tsubject?:string,\n\tbody?:string\n}\n\nconst O:MailtoHeaders = {};\nconst isIRI = true;\n\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\";  //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));  //expanded\n\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\";  //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\n\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str:string):string {\n\tconst decStr = pctDecChars(str);\n\treturn (!decStr.match(UNRESERVED) ? str : decStr);\n}\n\nexport default {\n\tscheme : \"mailto\",\n\n\tparse : function (components:MailtoComponents, options:URIOptions):MailtoComponents {\n\t\tconst to = components.to = (components.path ? components.path.split(\",\") : []);\n\t\tcomponents.path = undefined;\n\n\t\tif (components.query) {\n\t\t\tlet unknownHeaders = false\n\t\t\tconst headers:MailtoHeaders = {};\n\t\t\tconst hfields = components.query.split(\"&\");\n\n\t\t\tfor (let x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t\t\tconst hfield = hfields[x].split(\"=\");\n\n\t\t\t\tswitch (hfield[0]) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tconst toAddrs = hfield[1].split(\",\");\n\t\t\t\t\t\tfor (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n\t\t\t\t\t\t\tto.push(toAddrs[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subject\":\n\t\t\t\t\t\tcomponents.subject = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"body\":\n\t\t\t\t\t\tcomponents.body = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunknownHeaders = true;\n\t\t\t\t\t\theaders[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unknownHeaders) components.headers = headers;\n\t\t}\n\n\t\tcomponents.query = undefined;\n\n\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\tconst addr = to[x].split(\"@\");\n\n\t\t\taddr[0] = unescapeComponent(addr[0]);\n\n\t\t\tif (!options.unicodeSupport) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\taddr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t\t}\n\n\t\t\tto[x] = addr.join(\"@\");\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:MailtoComponents, options:URIOptions):URIComponents {\n\t\tconst to = toArray(components.to);\n\t\tif (to) {\n\t\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\t\tconst toAddr = String(to[x]);\n\t\t\t\tconst atIdx = toAddr.lastIndexOf(\"@\");\n\t\t\t\tconst localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t\t\tlet domain = toAddr.slice(atIdx + 1);\n\n\t\t\t\t//convert IDN via punycode\n\t\t\t\ttry {\n\t\t\t\t\tdomain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t\t}\n\n\t\t\t\tto[x] = localPart + \"@\" + domain;\n\t\t\t}\n\n\t\t\tcomponents.path = to.join(\",\");\n\t\t}\n\n\t\tconst headers = components.headers = components.headers || {};\n\n\t\tif (components.subject) headers[\"subject\"] = components.subject;\n\t\tif (components.body) headers[\"body\"] = components.body;\n\n\t\tconst fields = [];\n\t\tfor (const name in headers) {\n\t\t\tif (headers[name] !== O[name]) {\n\t\t\t\tfields.push(\n\t\t\t\t\tname.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n\t\t\t\t\t\"=\" +\n\t\t\t\t\theaders[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (fields.length) {\n\t\t\tcomponents.query = fields.join(\"&\");\n\t\t}\n\n\t\treturn components;\n\t}\n}\n","import { URIRegExps } from \"./uri\";\nimport { buildExps } from \"./regexps-uri\";\n\nexport default buildExps(true);\n","import { URIComponents, URIOptions } from \"../uri\";\n\nexport default {\n\tscheme : \"http\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//report missing host\n\t\tif (!components.host) {\n\t\t\tcomponents.error = components.error || \"HTTP URIs must have a host.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//normalize the default port\n\t\tif (components.port === (String(components.scheme).toLowerCase() !== \"https\" ? 80 : 443) || components.port === \"\") {\n\t\t\tcomponents.port = undefined;\n\t\t}\n\t\t\n\t\t//normalize the empty path\n\t\tif (!components.path) {\n\t\t\tcomponents.path = \"/\";\n\t\t}\n\n\t\t//NOTE: We do not parse query strings for HTTP URIs\n\t\t//as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t//and not the HTTP spec.\n\n\t\treturn components;\n\t}\n};\n","import { URIComponents, URIOptions } from \"../uri\";\nimport http from \"./http\";\n\nexport default {\n\tscheme : \"https\",\n\tdomainHost : http.domainHost,\n\tparse : http.parse,\n\tserialize : http.serialize\n}\n","import { URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, SCHEMES } from \"../uri\";\n\nconst NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\";\nconst PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\";\nconst TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\";\nconst NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\";\nconst URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\");\nconst URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\");\nconst URN_PARSE = /^([^\\:]+)\\:(.*)/;\nconst URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g;\n\n//RFC 2141\nexport default {\n\tscheme : \"urn\",\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst matches = components.path && components.path.match(URN_PARSE);\n\n\t\tif (matches) {\n\t\t\tconst scheme = \"urn:\" + matches[1].toLowerCase();\n\t\t\tlet schemeHandler = SCHEMES[scheme];\n\n\t\t\t//in order to serialize properly,\n\t\t\t//every URN must have a serializer that calls the URN serializer\n\t\t\tif (!schemeHandler) {\n\t\t\t\t//create fake scheme handler\n\t\t\t\tschemeHandler = SCHEMES[scheme] = {\n\t\t\t\t\tscheme : scheme,\n\t\t\t\t\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t\t\t\t\treturn components;\n\t\t\t\t\t},\n\t\t\t\t\tserialize : SCHEMES[\"urn\"].serialize\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcomponents.scheme = scheme;\n\t\t\tcomponents.path = matches[2];\n\n\t\t\tcomponents = schemeHandler.parse(components, options);\n\t\t} else {\n\t\t\tcomponents.error = components.error || \"URN can not be parsed.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst scheme = components.scheme || options.scheme;\n\n\t\tif (scheme && scheme !== \"urn\") {\n\t\t\tconst matches = scheme.match(URN_SCHEME) || [\"urn:\" + scheme, scheme];\n\t\t\tcomponents.scheme = \"urn\";\n\t\t\tcomponents.path = matches[1] + \":\" + (components.path ? components.path.replace(URN_EXCLUDED, pctEncChar) : \"\");\n\t\t}\n\n\t\treturn components;\n\t}\n};\n","import { URIComponents, URIOptions } from \"../uri\";\nimport { SCHEMES } from \"../uri\";\n\nconst UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n\n//RFC 4122\nexport default {\n\tscheme : \"urn:uuid\",\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tif (!options.tolerant && (!components.path || !components.path.match(UUID))) {\n\t\t\tcomponents.error = components.error || \"UUID is not valid.\";\n\t\t}\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//ensure UUID is valid\n\t\tif (!options.tolerant && (!components.path || !components.path.match(UUID))) {\n\t\t\t//invalid UUIDs can not have this scheme\n\t\t\tcomponents.scheme = undefined;\n\t\t} else {\n\t\t\t//normalize UUID\n\t\t\tcomponents.path = (components.path || \"\").toLowerCase();\n\t\t}\n\n\t\treturn SCHEMES[\"urn\"].serialize(components, options);\n\t}\n};\n","import { SCHEMES } from \"./uri\";\n\nimport http from \"./schemes/http\";\nSCHEMES[\"http\"] = http;\n\nimport https from \"./schemes/https\";\nSCHEMES[\"https\"] = https;\n\nimport mailto from \"./schemes/mailto\";\nSCHEMES[\"mailto\"] = mailto;\n\nimport urn from \"./schemes/urn\";\nSCHEMES[\"urn\"] = urn;\n\nimport uuid from \"./schemes/urn-uuid\";\nSCHEMES[\"urn:uuid\"] = uuid;\n\nexport * from \"./uri\";\n"]}