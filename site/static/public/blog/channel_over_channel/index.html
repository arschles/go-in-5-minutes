<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Go In 5 Minutes, a screencast series that presents short, informative and practical tips, patterns and best practices to Go developers."/>
<meta name="keywords" content="Programming, Go, Golang, Software, Software Engineering, Software Development, Technology, Screencast"/>
<meta name="author" content="Aaron Schlesinger"/>
<title>Go In 5 Minutes - Short, helpful screencasts for professional Go developers</title>

<link href="/css/bootstrap-3.3.5.min.css" rel="stylesheet"/>
<link href="/css/bootstrap-theme-3.3.5.min.css" rel="stylesheet"/>
<link href="/css/common.css" rel="stylesheet"/>
<link href='https://fonts.googleapis.com/css?family=Varela+Round|Cousine:400,700' rel='stylesheet' type='text/css'>
<link rel="icon" type="image/jpeg" href="/img/gopher-student.jpg">

  <link href="/css/blog.css" rel="stylesheet"/>
  
</head>
<body class="container-fluid">
  <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand gifm-logo" href="/">Go In 5 Minutes</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li><a href="/screencasts">Episodes</a></li>
        <li><a href="/subscribe">Subscribe</a></li>
        <li><a href="/backers">Backers</a></li>
        <li>
          <a href="https://bitly.com/goin5minutes" target="_blank">
            Code <span class="glyphicon glyphicon-new-window" aria-hidden="true"></span>
          </a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
          <a href="https://www.patreon.com/goin5minutes" target="_blank">
            Become a Patron 
            <span class="glyphicon glyphicon-new-window" aria-hidden="true"></span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</nav>

  <div class="container">
    <div class="row text-left">
      <div class="col-sm-8 col-sm-offset-2">
        <h1 class="page-title bot-sm-1">
          Passing Channels over Channels
          <small>by Aaron Schlesinger</small>
          <div class="publish-date"><small>Monday, Sep 5, 2016</small></div>
        </h1>
      </div>
    </div>
    <div class="col-sm-8 col-sm-offset-2 text-center">
        <i>
          The Go in 5 minutes blog has a new home! 
          Head over to 
          <a href="https://medium.com/go-in-5-minutes">https://medium.com/go-in-5-minutes</a>
          to stay up to date. And give us a follow if you can, I'd really appreciate it!
        </i>
    </div>
    <div class="row text-center">
      <div class="col-sm-8 col-sm-offset-2 blog-content text-left top-sm-1">
        

<h1 id="passing-channels-over-channels">Passing Channels over Channels</h1>

<p>As most know, <a href="https://gobyexample.com/channels">channels</a> are one of the most powerful concurrency features in Go. Armed with Goroutines and the <code>select</code> statement, you can build correct, efficient and understandable concurrent programs that do complex things.</p>

<p>In essence, a channel is a shared, concurrency-safe queue. Its primary purpose is to pass data across concurrency boundaries (i.e. between goroutines). Another way to say that is: you can send or receive an instance of any <code>type</code> on a channel. I&rsquo;m going to focus on sending that <code>chan</code> type over a channel.</p>

<h1 id="why">Why</h1>

<p>One simple reason you&rsquo;d send a <code>chan</code> on a <code>chan</code> is to tell a goroutine to do work and then get an acknowledgement (ack hereafter) that it&rsquo;s finished doing that work.</p>

<p>Here&rsquo;s what such a channel looks like in Go code:</p>

<pre><code class="language-go">chanOverChan := make(chan chan int)
</code></pre>

<p>In English, this code means: &ldquo;a channel on which you can send or receive a channel of ints&rdquo;. When you see code that looks like the above, it&rsquo;s a safe bet that the sender is telling the receiver to do some computation and send the results to another goroutine, which may be the sender. We&rsquo;re going to focus on case where the sender is the receiver that the ack is forwarded to.</p>

<h1 id="patterns">Patterns</h1>

<p>You won&rsquo;t always see a simple <code>chan chan int</code>. Sometimes, the ack channel is stored inside a struct:</p>

<pre><code class="language-go">type data struct {
  retCh chan&lt;- int
}
dataCh := make(chan data)
</code></pre>

<p>And you might see the channel completely abstracted by a <code>func</code>:</p>

<pre><code class="language-go">type abstractedCh := chan func(int)
</code></pre>

<p>In this case, the sender can capture the channel inside the <code>func(int)</code> if they want &ndash; or they can send any other implementation they want. This strategy is called a <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">function closure</a>, and is extremely flexible.</p>

<h1 id="in-action">In Action</h1>

<p>Below are some code examples using the 3 strategies. In each case, We&rsquo;ll simulate the work using a simple <code>time.Sleep</code>.</p>

<h2 id="style-1-using-a-channel-inside-a-channel">Style 1: Using a Channel Inside a Channel</h2>

<p>Here&rsquo;s the simplest of the patterns in action. Generally this style will be easiest to read and understand, but it has some limits:</p>

<ul>
<li>Each <code>doStuff</code> goroutine sleeps for a set amount of time. You can&rsquo;t change the sleep time when you send on <code>ch</code></li>

<li><p>Each <code>doStuff</code> goroutine can <em>only</em> receive a <code>chan time.Duration</code> &ndash; no more data than that. We&rsquo;ll address that problem in the next style.</p>

<pre><code class="language-go">package main

import (
	&quot;log&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

// the function to be run inside a goroutine. It receives a channel on ch, sleeps for t, then sends t on the channel it received
func doStuff(t time.Duration, ch &lt;-chan chan time.Duration) {
	ac := &lt;-ch
	time.Sleep(t)
	ac &lt;- t
}

func main() {
	// create the channel-over-channel type
	sendCh := make(chan chan time.Duration)

	// start up 10 doStuff goroutines
	for i := 0; i &lt; 10; i++ {
		go doStuff(time.Duration(i+1)*time.Second, sendCh)
	}

	// send channels to each doStuff goroutine. doStuff will &quot;ack&quot; by sending its sleep time back
	recvCh := make(chan time.Duration)
	for i := 0; i &lt; 10; i++ {
		sendCh &lt;- recvCh
	}

	// receive on each channel we previously sent. this is where we receive the ack that doStuff sent back above
	var wg sync.WaitGroup // use this to block until all goroutines have received the ack and logged
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			dur := &lt;-recvCh
			log.Printf(&quot;slept for %s&quot;, dur)
		}()
	}
	wg.Wait()
}
</code></pre></li>
</ul>

<p>See this code in action at <a href="https://play.golang.org/p/-1lY-4gd4N">https://play.golang.org/p/-1lY-4gd4N</a>.</p>

<h2 id="style-2-using-a-channel-stored-inside-a-struct">Style 2: Using a Channel Stored Inside a Struct</h2>

<p>This code will look almost identical to the previous snippet, with 2 exceptions:</p>

<ul>
<li>The ack channel will be stored inside a <code>struct</code></li>

<li><p>The sleep time will be stored inside that same <code>struct</code>, so we can pass it over the <code>channel</code></p>

<ul>
<li><p>This makes the code more flexible, because we can tell <code>doStuff</code> how long to sleep when we <em>send</em> to it, rather than when we start it</p>

<pre><code class="language-go">package main

import (
	&quot;log&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

// the struct that we'll pass over a channel to a goroutine running doStuff
type process struct {
	dur time.Duration
	ch  chan time.Duration
}

// the goroutine function. will receive a process struct 'p' on ch, sleep for p.dur, then send p.dur on p.ch
func doStuff(ch &lt;-chan process) {
	proc := &lt;-ch
	time.Sleep(proc.dur)
	proc.ch &lt;- proc.dur
}

func main() {
	// start up the goroutines
	sendCh := make(chan process)
	for i := 0; i &lt; 10; i++ {
		go doStuff(sendCh)
	}

	// store an array of each struct we sent to the goroutines
	processes := make([]process, 10)
	for i := 0; i &lt; 10; i++ {
		dur := time.Duration(i+1) * time.Second
		proc := process{dur: dur, ch: make(chan time.Duration)}
		processes[i] = proc
		sendCh &lt;- proc
	}

	// recieve on each struct's ack channel
	var wg sync.WaitGroup // use this to block until all goroutines have received the ack and logged
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go func(ch &lt;-chan time.Duration) {
			defer wg.Done()
			dur := &lt;-ch
			log.Printf(&quot;slept for %s&quot;, dur)
		}(processes[i].ch)
	}
	wg.Wait()
}
</code></pre></li>
</ul></li>
</ul>

<p>See this code in action at <a href="https://play.golang.org/p/bJoiGP9ua2">https://play.golang.org/p/bJoiGP9ua2</a>.</p>

<h2 id="style-3-using-a-channel-inside-a-function-closure">Style 3: Using a Channel Inside a Function Closure</h2>

<p>This code will look different from the previous examples, because the <code>doStuff</code> function won&rsquo;t know <em>anything</em> about a return channel. That fact is both good and bad. On the up side, you can change your code later to do anything you want inside that function (e.g. good for testing!), but on the down side, you can&rsquo;t pass dynamic <code>time.Duration</code>s into the <code>doStuff</code> goroutines, as you could in the previous example.</p>

<pre><code class="language-go">package main

import (
	&quot;log&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

func doStuff(dur time.Duration, ch &lt;-chan func(time.Duration)) {
	ackFn := &lt;-ch
	time.Sleep(dur)
	ackFn(dur)
}

func main() {
	// start up the doStuff goroutines
	sendCh := make(chan func(time.Duration))
	for i := 0; i &lt; 10; i++ {
		dur := time.Duration(i+1) * time.Second
		go doStuff(dur, sendCh)
	}

	// create the channels that will be closed over, create functions that close over each channel, then send them to the doStuff goroutines
	recvChs := make([]chan time.Duration, 10)
	for i := 0; i &lt; 10; i++ {
		recvCh := make(chan time.Duration)
		recvChs[i] = recvCh
		fn := func(dur time.Duration) {
			recvCh &lt;- dur
		}
		sendCh &lt;- fn
	}

	// receive on the closed-over functions
	var wg sync.WaitGroup // use this to block until all goroutines have received the ack and logged
	for _, recvCh := range recvChs {
		wg.Add(1)
		go func(recvCh &lt;-chan time.Duration) {
			defer wg.Done()
			dur := &lt;-recvCh
			log.Printf(&quot;slept for %s&quot;, dur)
		}(recvCh)
	}
	wg.Wait()
}
</code></pre>

<p>See this code in action at <a href="https://play.golang.org/p/JAtGxdBVRW">https://play.golang.org/p/JAtGxdBVRW</a>.</p>

<h1 id="summary">Summary</h1>

<p>There are uses for this channel-over-channel strategy, but the ack one is simple and powerful. Further, in many cases when you need to &ldquo;return&rdquo; something to another goroutine, sending it a <code>chan</code> on which it can return a value is often the easiest way to do it. This pattern can even be useful when you want to wait for a goroutine to ack its completion. Note, however, that you can also do ack-ing with a <code>sync.WaitGroup</code>.</p>

      </div>
    </div>
    <div class = "row text-center top-sm-1">
      <div class="col-sm-4 col-sm-offset-4">
        Thanks for reading! Ready for more?
        <a class="btn-lg btn-success btn-block" type="button" href="/screencasts">
          Check out the Screencasts
        </a>
      </div>
    </div>
    <div class="row text-center footer">
      <div class="col-sm-2"></div>
<div class="col-sm-4 text-left">
  <p>
    <a href="https://gum.co/gifm-1-10">
      Buy the bundle
      <span class="glyphicon glyphicon-download" aria-hidden="true"></span>
    </a>
  </p>
  <p>
    <a href="/subscribe">Sign up for the Newsletter</a>
  </p>
  <p>
    <a href="mailto:arschles+gifm@gmail.com">
      Contact
      <span class="glyphicon glyphicon-envelope" aria-hidden="true"></span>
    </a>
  </p>
</div>

<div class="col-sm-4 text-right">
  <p>
    Glyphicons courtesy of <a href="http://glyphicons.com">glyphicons.com</a>
  </p>
  <p>
    Gopher icons attributed to <a href="http://reneefrench.blogspot.com/">Renee French</a>
  </p>
  <p>Proudly created with <a href="http://gohugo.io/">Hugo</a></p>
</div>
<div class="col-sm-2"></div>

    </div>
  </div>
  <script type="text/javascript" src="/js/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="/js/bootstrap-3.3.5.min.js"></script>
<script type="text/javascript" src="/js/common.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69831218-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>
